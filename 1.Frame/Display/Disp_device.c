#include <config.h>
#include <display_device.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/fb.h>
#include <string.h>

static int FBDeviceInit(void);								  /*显示设备初始化*/
static int FBShowPixel(int iX, int iY, unsigned int dwColor); /*显示一个像素点*/
static int FBCleanScreen(unsigned int dwBackColor);			  /*清屏*/

static int g_fd; /*显示设备文件描述符*/

static struct fb_var_screeninfo g_tFBVar; /*定义显示设备Var结构体参数*/
static struct fb_fix_screeninfo g_tFBFix; /*定义显示设备Fix结构体参数*/
static unsigned char *g_pucFBMem;		  /*LCD显存*/
static unsigned int g_dwScreenSize;		  /*LCD屏幕字节数大小*/

static unsigned int g_dwLineWidth;
static unsigned int g_dwPixelWidth;

static T_DispOpr g_tFBOpr = {
	.name = "fb",
	.DeviceInit = FBDeviceInit,
	.ShowPixel = FBShowPixel,
	.CleanScreen = FBCleanScreen,
};

/*
*********************************************************************************************************
*	函 数 名: FBDeviceInit
*	功能说明: LCD屏幕显示设备初始化
*	形    参: 无
*	返 回 值: 无
*   日期          版本号        修改人
*   2023/12/11    V1.0        @尝试早睡
*********************************************************************************************************
*/
static int FBDeviceInit(void)
{
	int ret;

	g_fd = open(FB_DEVICE_NAME, O_RDWR);
	if (0 > g_fd)
	{
		DBG_PRINTF("can't open %s\n", FB_DEVICE_NAME);
	}

	ret = ioctl(g_fd, FBIOGET_VSCREENINFO, &g_tFBVar); /*获取LCD屏幕的Var结构体数据*/
	if (ret < 0)
	{
		DBG_PRINTF("can't get fb's var\n");
		return -1;
	}

	ret = ioctl(g_fd, FBIOGET_FSCREENINFO, &g_tFBFix); /*获取LCD屏幕的Fix结构体数据*/
	if (ret < 0)
	{
		DBG_PRINTF("can't get fb's fix\n");
		return -1;
	}

	g_dwScreenSize = g_tFBVar.xres * g_tFBVar.yres * g_tFBVar.bits_per_pixel / 8;
	g_pucFBMem = (unsigned char *)mmap(NULL, g_dwScreenSize, PROT_READ | PROT_WRITE, MAP_SHARED, g_fd, 0);
	if (0 > g_pucFBMem)
	{
		DBG_PRINTF("can't mmap\n");
		return -1;
	}
	/*将获取到的数据赋值到显示设备结构体*/
	g_tFBOpr.iXres = g_tFBVar.xres;
	g_tFBOpr.iYres = g_tFBVar.yres;
	g_tFBOpr.iBpp = g_tFBVar.bits_per_pixel;

	g_dwLineWidth = g_tFBVar.xres * g_tFBVar.bits_per_pixel / 8; /*计算每行的字节数*/
	g_dwPixelWidth = g_tFBVar.bits_per_pixel / 8;				 /*计算每个像素的是第几个字节*/

	return 0;
}

/*
*********************************************************************************************************
*	函 数 名: FBShowPixel
*	功能说明: 显示一个像素点
*	形    参: iX: 横坐标 iY: 纵坐标 dwColor: 颜色
*	返 回 值: 无
*   日期          版本号        修改人
*   2023/12/11    V1.0        @尝试早睡
*********************************************************************************************************
*/
static int FBShowPixel(int iX, int iY, unsigned int dwColor)
{
	unsigned char *pucFB;
	unsigned short *pwFB16bpp;
	unsigned int *pdwFB32bpp;
	unsigned short wColor16bpp; /* 565 */
	int iRed;
	int iGreen;
	int iBlue;

	if ((iX >= g_tFBVar.xres) || (iY >= g_tFBVar.yres))
	{
		DBG_PRINTF("out of region\n");
		return -1;
	}

	pucFB = g_pucFBMem + g_dwLineWidth * iY + g_dwPixelWidth * iX;
	pwFB16bpp = (unsigned short *)pucFB;
	pdwFB32bpp = (unsigned int *)pucFB;

	switch (g_tFBVar.bits_per_pixel)
	{
	case 8:
	{
		*pucFB = (unsigned char)dwColor;
		break;
	}
	case 16:
	{
		iRed = (dwColor >> (16 + 3)) & 0x1f;
		iGreen = (dwColor >> (8 + 2)) & 0x3f;
		iBlue = (dwColor >> 3) & 0x1f;
		wColor16bpp = (iRed << 11) | (iGreen << 5) | iBlue;
		*pwFB16bpp = wColor16bpp;
		break;
	}
	case 32:
	{
		*pdwFB32bpp = dwColor;
		break;
	}
	default:
	{
		DBG_PRINTF("can't support %d bpp\n", g_tFBVar.bits_per_pixel);
		return -1;
	}
	}

	return 0;
}

/*
*********************************************************************************************************
*	函 数 名: FBCleanScreen
*	功能说明: LCD清屏函数
*	形    参: dwBackColor: 清屏后的背景颜色
*	返 回 值: 无
*   日期          版本号        修改人
*   2023/12/11    V1.0        @尝试早睡
*********************************************************************************************************
*/
static int FBCleanScreen(unsigned int dwBackColor)
{
	unsigned char *pucFB;
	unsigned short *pwFB16bpp;
	unsigned int *pdwFB32bpp;
	unsigned short wColor16bpp; /* 565 */
	int iRed;
	int iGreen;
	int iBlue;
	int i = 0;

	pucFB = g_pucFBMem;
	pwFB16bpp = (unsigned short *)pucFB;
	pdwFB32bpp = (unsigned int *)pucFB;

	switch (g_tFBVar.bits_per_pixel)
	{
	case 8:
	{
		memset(g_pucFBMem, dwBackColor, g_dwScreenSize);
		break;
	}
	case 16:
	{
		iRed = (dwBackColor >> (16 + 3)) & 0x1f;
		iGreen = (dwBackColor >> (8 + 2)) & 0x3f;
		iBlue = (dwBackColor >> 3) & 0x1f;
		wColor16bpp = (iRed << 11) | (iGreen << 5) | iBlue;
		while (i < g_dwScreenSize)
		{
			*pwFB16bpp = wColor16bpp;
			pwFB16bpp++;
			i += 2;
		}
		break;
	}
	case 32:
	{
		while (i < g_dwScreenSize)
		{
			*pdwFB32bpp = dwBackColor;
			pdwFB32bpp++;
			i += 4;
		}
		break;
	}
	default:
	{
		DBG_PRINTF("can't support %d bpp\n", g_tFBVar.bits_per_pixel);
		return -1;
	}
	}

	return 0;
}

/*
*********************************************************************************************************
*	函 数 名: FBInit
*	功能说明: LCD清屏函数,给其他函数使用的接口
*	形    参: 无
*	返 回 值: 无
*   日期          版本号        修改人
*   2023/12/11    V1.0        @尝试早睡
*********************************************************************************************************
*/
int FBInit(void)
{
	return RegisterDispOpr(&g_tFBOpr);
}
